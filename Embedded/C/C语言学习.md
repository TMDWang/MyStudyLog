### 一 C语言知识总结

#### 1 基操

##### 1.1 void *

##### 1.2 结构体struct

##### 1.3 typedef

##### 1.4 (void)variable

##### 1.5 位域

##### 1.6 extern

##### 1.7 |、 &、 ||、 &&

##### 1.8 break & continue

##### 1.9 字符 & 字符串

C的字符串常量是用单引号括起来的一个字符，如'?'、'a'、'b'、'C'等都是字符常量。字符型变量用来存放字符常量，注意只能放一个字符，不能在一个字符变量中放一个字符串或若干支付。一个字符变量在内存中占一个字节。

C语言中是没有**字符串**变量的，要表示字符串需要用字符数组或者字符指针，如下所示：

```c
char string[] = "Hello world!";
char *string = "Hello world!";
```

**字符常量是由一对单引号括起来的单个字符，字符串常量是用一对双引号括起来的字符序列**

**C规定**：在每一个字符串的结尾加一个“字符串结束标志”，一边系统据此判断字符串是否结束。C规定以字符‘\0’作为字符串结束标志。'\0'是一个ASCII码为0的字符；从ASCII代码表中可以看到ASCII码为0的字符是“空操作符”，即它不引起任何控制动作，也不是一个可显示的字符，如果有一个字符串“CHINA”，实际上在内存中是'C'、'H'、'I'、'N'、'A'、'\0'，它占的不是5个而是6个字节，最后一个字节为'\0'，但在输出是不输出'\0'，输出是遇到'\0'表示字符串输出结束，写字符串时不必加'\0'，它是系统自动加上的。

##### 1.10 malloc() & free()

##### 1.11 \_\_attribute\_\_()

\_\_attribute\_\_可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。

\_\_attribute\_\_书写特征是：\_\_attribute\_\_前后都有<mark>两个下划线</mark>，并且后面会紧跟一对圆括号，括号里面是\_\_attribute\_\_参数。

\_\_attribute\_\_语法格式为：\_\_attribute\_\_((attribute_list))。

关键字\_\_attribute\_\_也可以对结构体（struct）或共用体（union）进行属性设置。大概有一下6个参数：

aligned、packed、transparent_union、unused、deprecated、may_alias

在使用\_\_attribute\_\_参数时，你也可以在参数的前后都加上“__”，例如使用“\_\_aligned\_\_”而不是“aligned”，这样你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。

**函数属性（Function Attribute）**

##### 1.12 作用域

##### 1.13 union 共用体

定义格式为：

```c
union 共用体名  //共用体也被称为联合或联合体
{
    成员列表;
};
```

结构体和共用体的区别：

- 结构体的各个成员会占用不同的内存，相互之间没有影响；而公用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。
- 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

共用体也是一种自定义类型，可以通过它来创建变量，例如：

```c
//先定义公用体，再创建变量
union data
{
    int n;
    char ch;
    double f;
};

union data a, b, c;

//在定义共用体的同时创建变量
union data
{
    int n;
    char ch;
    double f;
} a, b, c;

//如果不再定义新的变量，也可以将共用体的名字省略
union
{
    int n;
    char ch;
    double f;
} a, b, c;
```

上面公用体data中，成员f占用内存最多，为8字节，所以data类型的变量占用8个字节。

##### 1.14 sizeof()

使用sizeof()获取变量所占内存大小时，由于字节对齐问题，可能会得到与预期不符的结果。特别是在获取结构体所占内存大小时（in bytes）。

```c
sizeof(int);
sizeof(word);
......
```

##### 1.15 switch-case-break-default

##### 1.16 volatile

##### 1.17 enum

枚举是C语言中的一种基本数据类型，它可以让数据更简洁，更易读。语法定义格式为：

```c
enum 枚举名 { 枚举元素1, 枚举元素2, ...... };
```

###### 枚举变量的定义

1.先定义枚举类型，再定义枚举变量

```c
enum DAY
{
    MON=1, TUE, WED, THU, FRI, SAT, SUN 
};
enum DAY day;
```

2.定义枚举类型的同时定义枚举变量

```c
enum DAY
{
    MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

3.省略枚举名称，直接定义枚举变量

```c
enum
{
    MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

如果未给枚举成员明显赋值，则第一个枚举成员的默认值为整形的0，后续枚举成员的值再前一个成员上加1。上例中第一个枚举成员的值给定为1，后续没有指定值的枚举元素，其值为前一元素加1。

##### 1.18 大小端模式

**<mark>大端模式</mark>**：指数据的**高字节**保存在内存的**低地址**中，而数据的低字节保存在内存的高地址中，这样的存储模式有点类似于把数据当作字符串顺序处理；地址由小向大增加，而数据从高位往低位放；这和我们的<mark>阅读习惯一致</mark>。

**小端模式**：指数据的**高字节**保存在内存的**高地址**中，而数据的低字节保存在内存的低地址中，这中存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

#### 2 指针

##### 2.1 函数指针是指针

函数指针，其本质时一个指针变量，一个指向函数的指针变量。

声明格式如下：

```c
/* fun是函数指针，指向的函数有x，y两个输入参数，返回一个int类型的数值 */
int (*fun)(int x, int y);

/* 函数指针的赋值方式有以下两种，即将函数的地址赋给函数指针 */
fun = &Function;
或
fun = Function;  //函数名就是一个函数指针!!!
```

取址运算符&不是必须的，因为函数标识符（函数名）就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。

调用函数指针的方式也有以下两种：

```c
x = (*fun)(args...);  //建议使用这种方式
或
x= fun(args...);
```

##### 2.2 指针函数是函数

指针函数，就是一个返回指针的函数，其本质是一个函数，该函数的返回值是一个指针。

下面是一个普通的函数声明：

```c
/* fun为返回int类型的函数 */
int fun(int x, int y);
```

下面看一下指针函数的声明：

```c
/* 声明的函数fun为一个返回int*类型的函数，返回值是指向int类型的指针，是一个地址 */
int *fun(int x, int y);
```

指针函数的写法：

```c
int *fun(int x, int y);
int * fun(int x, int y);
int* fun(int x, int y);  //建议使用这种方式
```

**注意：在调用指针函数时，需要一个同类型的指针来接收其函数的返回值。不过也可以将其返回值定义为void *类型，在调用的时候强制转换返回值为自己想要的类型。**

```c
/* 将指针函数的返回值指定为void*类型 */
void* fun(int x, int y);

/* 调用时将返回值强制转换为自己需要的类型 */
int *data = (int *)fun(x, y);
```

**不过不建议使用这种方法，强制转换可能会带来风险。**

#### 3 内存管理

#### Table1 格式符

| 格式符  | 输出类型 |
|:----:|:----:|
| "%d" |      |
| "%c" |      |
| "%f" |      |
| "%s" |      |
| ""   |      |
| ""   |      |
| ""   |      |
| ""   |      |
| ""   |      |

#### Table2 转义字符

| 字符形式 | 含义               | ASCII码 |
|:----:|:----------------:|:------:|
| \n   | 换行，将当前位置移动到下一行开头 | 10     |
| \t   | 水平制表，跳到下一个tab位置  | 9      |
| \b   | 退格，将当前位置移动到前一列   | 8      |
| \r   | 将当前位置移动到本行开头     | 13     |

### 二 常用的库函数

#### 1 标准库函数

##### 1.1 scanf()

scanf()函数从标准输入读取字符并根据格式字符串对它们进行转换-类似于printf函数的逆操作。scanf函数接受几个参数，其中第1个参数是一个格式字符串，用于描述期望的输入类型。剩余几个参数都是变量，用于存储函数所读取的输入数据。scanf函数的返回值是函数成功转换并存储于参数中的个数。

**警告：**

- 对于scanf函数，所有的标量参数前面必须加上一个“&”符号（取址运算符）。
- 需要注意格式代码，它与printf函数的格式代码颇为相似却又并不完全相同，很容易引起混淆。

##### 1.2 getchar()

getchar()函数从标准输入读取一个字符并返回它的值。如果输入中不再存在任何字符，函数就会返回常量EOF（在stdio.h中定义，我觉得是End Of File），用于提示文件的结尾。

##### 1.3 memcpy()

函数原型：

```c
void *memcpy(void *destin, void *source, unsigned n);
```

参数：

- destin--指向用于存储复制内容的目标数组，类型强制转换为void*指针
- source--指向要被复制的数据源，类型强制转换为void*指针
- n--要被复制的字节数

返回值：返回一个指向目标存储区destin的指针。

功能：从**源source**所指向的内存地址的起始位置开始拷贝**n个字节**到**目标destin**所指的内存地址的起始位置。

头文件：

```c
c:        #include<string.h> 
c++:      #include<cstring>
```

##### 1.4 memset()

函数原型：

```c
extern void *memset(void *s, int ch, size_t n);
```

参数：

- s--指针或者数组
- ch--要赋给s的值
- n--s的长度

功能：将s中当前位置后面的n个字节（typedef unsigned int size_t）用ch替换并返回s。

##### 1.5 memcmp()

函数原型：

```c
int memcmp(const void *str1, const void *str2, size_t n);
```

参数：

- str1--指向内存块的指针
- str2--指向内存块的指针
- n--要比较的字节数

功能：比较内存区域buf1和buf2的前count个字节。

头文件：

```c
#include <string.h> 或 #include <memory.h>
```

返回值：

如果返回值 < 0，则表示str1 < str2。

如果返回值 > 0，则表示str1 > str2。

如果返回值 = 0，则表示str1 = str2。

##### 1.6 offsetof()

### 三 好的用法

#### 1 注释

##### 1.1 利用预处理指令#if和#endif注释一段代码

如果你试图在一段代码的首尾分别加上/*符号来注释掉这段代码，不一定能如愿。如果这段代码中原先含有注释存在，这样做会出问题的。要从逻辑上删除一段C代码（而不是真正的从文件中删除），更好的办法是使用#if指令。如下所示：

```c
#if 0
    statements;
#endif
```

如此，在#if和#endif之间的程序就可以有效地从程序中去除，即使这段代码之间原先存在注释也无妨，所以这是一种更为安全的方法。

### 四 注意注意注意

#### 1 变量初始化

变量在声明是需要初始化，要不然它的初始值将是一个不可预料的值，也就是垃圾。不过如果你对这个变量的第一个操作就是对它赋值，也可以不在声明时对其初始化。

```c
int a = 223;
int b;

b = max(32, 223);  //对b的第一个操作就是对其赋值。
```

#### 2 空语句

while语句（或其他）之后的单独一个分号称为**空语句（empty statement）**,它就是应用于下面的场合，即语法要求这个地方出现一条语句但又无需执行任何任务的时候，这个分号独占一行，这是为了防止读者错误地以为接下来的语句也是循环体的一部分。

```c
while(1)  //这是个死循环
{  //可以省去的
    ;  //空语句
}

statement;
```

#### 3 数组

当数组名作为实参时，传给函数的实际上是一个指向数组起始位置的指针，也就是数组在内存中的地址。正因为实际传递的是一个指针而不是一份数组的拷贝，才使数组名作为参数时具备了传址调用的语义。函数可以按照操纵指针的方式来操纵实参，也可以像使用数组名一样用下标来引用数组的元素。

#### 4 结构体字节对齐 & 占用字节数

字节对齐原则：

1. 以结构体成员中占内存最多的数据类型所占的字节数为标准，所有的成员在分配内存时都要与这个长度对齐。
2. 在1的基础上，如果占内存最多的数据类型所占的字节数为N，理论上所有成员在分配内存时都是紧接在前一个变量后面依次填充的，但是如果是“以N对齐”为原则，那么，如果一行中剩下的空间不足以填充某成员变量，即剩下的空间小于某成员变量的数据类型所占的字节数，则该成员变量在分配内存时另起一行分配。

```c
结构体1
struct student1
{
    char a;  //char类型变量占1字节内存空间
    char b;
    int  c;  //int类型变量占4字节内存空间
}data1;

结构体2
struct student2
{
    char a;
    int  c;
    char b;
}data2;

结构体3
struct student3
{
    char  name[10];  //占内存长度为10，但本质上是10个char变量，看成10个char变量即可
    int   age;
    char  sex;
    float score;     //float类型变量占4字节内存空间
}data3;
```

以上三个结构体分别占8、12、24字节内存空间。

#### 5 函数指针

函数的函数名实际上就是一个指针，函数名指向该函数的代码在内存中的首地址。

**用法1：返回类型 (*函数名) (参数表)**

```c
char (*pFun)(int);
char glFun(int a)
{
    return;
}

void main()
{
    pFun = glFun;  //将glFun函数赋值给函数指针pFun
    (*pFun)(2);    //*取值运算符，*pFun即glFun
}
```

**用法2：typedef 返回类型(*新类型)(参数表)**

```c
typedef char (*PTRFUN)(int);
PTRFUN pFun;
char glFun(int a)
{
    return;
}

void main()
{
    pFun = glFun;
    (*pFun)(2);
}
```

typedef的功能是定义新的类型。第一句就是定义了一种PTRFUN的类型，并定义这种类型为指向某种函数的指针，这种函数以一个int为参数并返回char类型。后面就可以像使用类型声明符“int”、“char”一样使用PTRFUN定义函数指针变量了。

#### 6 函数指针列表

#### 7 运算符的优先级

- 强制类型转换的优先级 > 移位运算符（"<<", ">>"）

#### 8 static修饰符

- **修饰局部变量**

静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且**静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变**。

变量在全局数据区分配内存空间；编译器自动对其初始化

其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束

- **修饰全局变量**

全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化。

普通全局变量对整个工程可见，其他文件可以使用extern外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量（否则编译器会认为它们是同一个变量）。

**静态全局变量仅对当前文件可见，其他文件不可访问**，其他文件可以定义与其同名的变量，两者互不影响。

在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

- **修饰函数**

函数的使用方法与全局变量类似，在函数的返回类型前加上static，就是静态函数。

1. **静态函数只能在声明它的文件中可见，其他文件不能引用该函数**
2. 不同的文件可以使用相同名字的静态函数，互不影响
3. 非静态函数可以在另一个文件中直接引用，甚至不必使用extern声明

#### 9 inline修饰符

#### 10 传值与传址

#### 11 const修饰符

- **常变量**

变量用const修饰，该变量的值不能被改变。任何改变此变量的代码都会产生变异错误。const加在数据类型前后均可

```c
const int i = 1;
int const j = 2;
i = 10;            //编译错误，常变量不能改变
j = 20;            //编译错误，常变量不能改变
```

- **常指针**

const与指针一起使用的时候有两种用法

1. const可用来限制指针不可变。也就是说指针指向的内存地址不可变，但可以随意改变该地址指向内存的内容。
   
   ```c
   int i = 10;
   //const用来修饰指针j，j不可变，j为指向int型变量的常指针
   int *const j = &i;    //常指针，指向int型变量
   (*j)++;    //可以改变变量的内容
   j++;       //错误，不能改变 常指针 的值（指向的内存地址）
   ```

2. const也可用来限制指针指向的内存不可变，单指针指向的内存地址可变。
   
   ```c
   int i = 10;
   //const用来修饰*j，*j不可变，j为指向int常量的指针
   const int *j = &i;    //指针，指向int型常量
   //也可以写成int const *j = &i;
   j++;    //指针指向的内存地址可变
   (*j)++;    //错误，不能改变指针指向内存的内容
   ```

以上两种方式可以组合起来使用，使指针和内存内容都不可变。

```c
int i = 10;
const int *const j = &i;    //指向int常量的常指针
j++;    //错误，不能改变指针指向的地址
(*j)++;    //错误，不能改变指针指向地址的内容（常变量）
```

- **const与引用“&”**

引用实际上就是变量的别名，引用有一下几条规则：

1. 声明变量时必须初始化

2. 一经初始化，引用不能再只想其他变量

3. 任何对引用的改变都将改变原变量

4. 引用和变量指向同一内存地址

```c
int i = 10;
int j = 20;
int &r = i;	//r是变量i的引用
int &s;     //错误，声明引用时必须初始化
i = 15;	    //i和r的值都等于15
i++;		//i和r的值都等于16
r = 18;    	//i和r的值都等于18
r = j;		//i和r的值都等于20，但r不是j的引用
r++;		//i和r的值都等于21
```

用const修饰引用，使引用不可修改，但这并不耽误引用反映任何对变量的修改。const加在数据类型前后均可。

```c
int i = 10;
int j = 100;
const int &r = i;
int const &s = j;
r = 20;		//错误，不能改变内容
s = 200;	//错误，不能改变内容
i = 20;		//i和r 都等于20
j = 200;	//j和s 都等于200
```

#### 12 extern

**程序的编译单位是源程序文件**，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数之外定义的变量则称之为外部变量，外部变量也就是我们所讲的全局变量。它的存储方式为静态存储，其生存周期为整个程序的生存周期。全局变量可以为本文件中的其他函数所共享，他的有效范围为从定义变量的位置开始到本院文件结束。

然而，如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字extern对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。

```c
#include <stdio.h>

int max(int x, int y);

int main(void)
{
    int result;
    /* 外部变量声明 */
    extern int g_x;
    extern int g_y;
    result = max(g_x, g_y);
    printf("the max value is %d\n", result);
    
    return 0;
}

/* 定义两个全局变量 */
int g_x = 10;
int g_y = 20;
int max(int x, int y)
{
    return (x>Y ? x : y);
}
```

代码中，全局变量g_x与g_y是在main函数之后声明的，因此它的作用域不在main函数中。如果我们需要在main函数中调用它们，就必须使用extern来对变量g_x和g_y作“外部变量声明”，以扩展全局变量的作用域，使作用域扩展到从声明开始到本文结束。

如果整个工程有多个源文件组成，在一个源文件中想引用另一个源文件已经定义的外部变量，同样只需在引用变量的文件中用extern关键字加以声明即可。

```c
/**** max.c ****/
#include <stdio.h>

/* 声明外部变量 */
extern int g_x;
extern int g_y;
int max()
{
	return (x>y ? x : y);
}
```

```c
/**** main.c ****/
#include <stdio.h>

/* 定义两个全局变量 */
int g_x = 10;
int g_y = 20;

int max();

int main()
{
    int result = max();
    printf("the max value is %d\n", result);
    
    return 0;
}
```

对于多个文件的工程，都可以采用上面这种方法来操作。对于模块化的程序文件，可在其文件中预先留好外部变量的接口，也就是只采用extern声明变量，而不定义变量。

通常，这些外部变量的接口都是在模块程序的头文件中声明的，当需要使用该模块时，只需要在使用时具体定义一下这些外部变量即可。

不过！需要特别注意的是，由于extern引用外部变量，可以在引用的模块内修改其变量的值，因此，如果有多个文件同时要对引用的变量进行操作，而且可能会修改该变量，那就会影响其他模块的使用。因此，要慎重使用extern。

### 五 扩展知识

