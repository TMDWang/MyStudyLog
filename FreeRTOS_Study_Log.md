# FreeRTOS Study Log

### 0 简介

**在FreeRTOS中，每一个执行的线程被叫做任务**

**内核对象包括任务、队列、信号量、事件组**

##### 0.1 一些术语的中英对照

|    English     |   中文   |
| :------------: | :------: |
| portable layer | 可移植层 |
|                |          |
|                |          |
|                |          |
|                |          |
|                |          |
|                |          |
|                |          |
|                |          |



### 1 数据类型 & 编码风格

**Tab键=4个空格。**

**对于源代码中过多类型转换的说明**

FreeRTOS源代码可以用许多不同的编译器进行编译，所有这些编译器在生成警告的方式和时间上都是不同的。特别是，不同的编译器希望以不同的方式使用类型转换。因此，FreeRTOS源代码中包含的类型转换比通常需要的要多。

#### 1.1 TickType_t & BaseType_t

FreeRTOS配置一个周期性的中断，称为tick interrupt。从FreeRTOS应用启动开始tick interrupt发生的次数称为tick count。tick count被用来度量时间。两个tick interrupt之间的用时称为tick period。TickType_t是用来保存tick count值的数据类型，即指定时间。TickType_t可以是uint16或者uint32，这取决于FreeRTOSConfig.h中变量configUSE_16_BIT_TICKS的值，设置为1则使用uint16，0为uint32，在32位处理器上没有理由使用uint16。

**BaseType_t**通常用作函数返回值的类型，一般是很有限的值，常用于pdTRUE/pdFALSE的布尔运算。BaseType_t的类型一般取决于处理器的位数，8-bit、16-bit、32-bit。

#### 1.2 变量命名规则

FreeRTOS中使用前缀（prefix）告诉你该变量的数据类型。具体如下表所示。

| 前缀（prefix） |    数据类型    | 示例 |
| :------------: | :------------: | :--: |
|      "c"       |      char      |      |
|      "s"       | int16_t(short) |      |
|      "l"       | int32_t(long)  |      |
|      "x"       |   BaseType_t   |      |

**"x"前缀也加在非标准的数据类型前面，例如structures、task handles、queue handles等。**

另外，**如果变量是unsigned也会加前缀"u"，如果变量是指针类型会加"p"**。例如，一个uint8_t类型的变量会加前缀"uc"，指向字符类型的指针会加前缀"pc"。

#### 1.3 函数命名规则

函数的前缀中有该函数返回值的类型和定义该函数的文件。如下表：

|         函数名          | 含义                                                |
| :---------------------: | :-------------------------------------------------- |
|    **x**QueueReceive    | 返回值类型为**BaseType_t**，在**queue.c**中定义     |
| **v**TaskPrioritySet()  | 返回值类型为**void**，在**task.c**中定义            |
| **pv**TimerGetTimerID() | 返回值类型为**指向void的指针**，在**timer.c**中定义 |

另外，**前缀"prv"表示该函数为定义该函数的文件私有的（private），即函数的作用域为该文件内。**

#### 1.4 宏命名规则

大部分的宏都用大写字母，并且加上小写字母前缀表明定义该宏的位置，如下表所示。

| 前缀                               |     定义该宏的位置      |
| :--------------------------------- | :---------------------: |
| port(例如，portMAX_DELAY)          | portable.h或portmacro.h |
| task(例如，taskENTER_CRITICAL())   |         task.h          |
| pd(例如，pdTRUE)                   |       projdefs.h        |
| config(例如，configUSE_PREEMPTION) |    FreeRTOSConfig.h     |
| err(例如，errQUEUE_FULL)           |       projdefs.h        |

**注意**：虽然信号量应用程序接口（semaphore API）几乎全部使用宏来编写，但其命名按照函数的命名规则，而不是宏的命名规则。

下表中的宏在整个FreeRTOS源代码中都可以使用。

|   宏    |  值  |
| :-----: | :--: |
| pdTRUE  |  1   |
| pdFALSE |  0   |
| pdPASS  |  1   |
| pdFAIL  |  0   |

### 2 堆内存管理

FreeRTOS中使用pvPortMalloc()和pvPortFree()代替C标准库中的malloc()和free()函数，它们的函数原型（prototype）是一样的。FreeRTOS提供了五种pvPortMalloc()函数和pvPortFree()函数的实现，用户编写的FreeRTOS应用可以使用其中的一种，或者使用自己提供的。

Heap_1.c中只实现了一个非常基础的pvPortMalloc()版本，没有实现pvPortFree()。因此适用于从不删除任务或者内核对象的应用。

![image-20200804232247161](FreeRTOS_illustration/image-20200804232247161.png)

Heap_4.c相当于Heap_2.c的增强版，在设计中推荐使用前者，保留后者是为了向下兼容。相比于Heap_1.c，Heap_2.c中允许释放内存。Heap_2.c不能像Heap_4.c可以把相邻的小内存块合并成大内存块，因此会产生内存碎片，不过它适用于重复创建删除占用相同内存大小任务的应用中。

![image-20200804232329557](FreeRTOS_illustration/image-20200804232329557.png)

Heap_3.c使用标准库中的malloc() & free()函数，因此堆内存的大小由连接器配置决定，不受configTOTAL_HEAP_SIZE设置的影响。Heap_3.c通过暂时挂起FreeRTOS调度器保证malloc() & free()函数thread-safe。

Heap_4.c同Heap_1.c和Heap_2.c一样将内存分为小块，且被静态分配。如前所述，Heap_4.c可以将临近的内存合并到一起，因此它适用于任务被重复创建和删除的应用，任务所占内存大小可不相同。

![image-20200804233951224](FreeRTOS_illustration/image-20200804233951224.png)

Heap_5.c中使用的内存分配与释放算法与Heap_4.c相同，但它不局限于分配单个静态声明的内存区域，它可以从多块分离的内存空间中分配内存。当FreeRTOS运行在系统内存映射不是一个连续的内存块是，它是相当有用的。

（只有）在使用Heap_5.c内提供的pvPortMalloc()函数时，必须提前明确地使用vPortDefineHeapRegions()函数初始化所使用的内存分配方案。在创建任何的内核对象（任务，队列，信号量等）之前必须先调用vPortDefineRegions()，该函数用来指定每一个内存块的开始地址和其大小，所有的内存块供Heap_5.c使用。（更详尽的说明尽在内核手册）

![image-20200806234149698](FreeRTOS_illustration/image-20200806234149698.png)

### 3 任务管理

**任务**用普通的C函数实现，唯一特殊的是他们的函数原型，必须返回void，必须给分空指针void *。例如下面：

```
void ATaskFunction(void *pvParameters);
```

**每个任务本身都是一个小程序，它有一个入口点，通常会一直运行在死循环中，并永远不会退出。**FreeRTOS任务绝不允许从它的实现函数中以任何方式退出，不能包含return语句，不允许在函数结束时运行。如果任务不再需要了，可以删除它。下图为创建任务的例子。

![image-20200807002419298](FreeRTOS_illustration/image-20200807002419298.png)

#### 3.1 任务状态（Task States）

一个应用程序可以由许多任务组成。单核处理器运行应用程序时在任一时刻只有一个任务可以执行。这意味着任务可以有运行（Running）和非运行（Not Running）两个状态。

![image-20200807165136069](FreeRTOS_illustration/image-20200807165136069.png)

任务从非运行态转化到运行态时称为"switched in"或者"swapped in"。相反的，任务宠运行态转化到非运行态称为"switched out"或"swapped out"。**FreeRTOS scheduler（调度器）是唯一可以转换任务状态的实体**。

#### 3.2 创建任务

**xTaskCreate()函数**

xTaskCreate()函数用于创建任务（此函数可能是最复杂的API Functions），在FreeRTOS V9.0.0中还包含xTaskCreateStatic()函数，该函数在编译时为任务的创建静态分配内存。xTaskCreate()函数原型如下图所示：

![image-20200808035645183](FreeRTOS_illustration/image-20200808035645183.png)

**参数**

**pvTaskCode**：任务是简单的C函数，通常实现为一个死循环。pvTaskCode参数为指向该任务的指针（实际上，就是任务的函数名）。

**pcName**：任务的一个描述。在FreeRTOS中不会用到它，他的存在纯粹是为了debugging目的。通过一个可读的名字识别任务相对于通过任务句柄识别的有点是显而易见的。configMAX_TASK_NAME_LEN定义了该名字可以占用的最大长度（包含结束符），如果超过最大值，会被切掉。

**usStackDepth**：任务创建时，内核会为每一个任务都分配一个属于该任务唯一的栈，usStackDepth参数告诉内核该任务需要的栈大小，单位是字words。常量configMINIMAL_STACK_SIZE规定了空闲任务使用的栈大小，该常量也是所有任务栈大小的最小值。

**pvParameters**：任务接受一个指向void的指针。pvParameters的值就是传入任务的值。

**uxPriority**：任务执行的优先级，优先级可以设置为最低的0到最高优先级（configMAX_PRIORITIES - 1），常量configMAX_PRIORITIES由用户定义。如果给定的优先级数值大于（configMAX_PRIORITIES - 1），则会将其优先级设置为最大优先级。

**pxCreatedTask**：pxCreatedTask参数用作当前创建任务的句柄。该句柄可以用来改变该任务的优先级，或删除该任务。如果你的应用程序中用不上该句柄，可将其设置为NULL。

**返回值**

返回值可能是**pdPASS**，表示任务创建成功，也可能是**pdFAIL**，表示任务创建失败，原因是内存不足。

#### 3.3 任务优先级 Task Priorities（重点）

在调度器启动之后，可以通过vTaskPrioritySet()函数改变创建任务时给定的初始任务优先级。任务优先级的最大值configMAX_PRIORITIES在FreeRTOSConfig.h文件中定义，编译时配置为常量。数字越小优先级越低，0代表最低优先级。多个任务可以有相同的优先级，确保设计的灵活性最大。

**FreeRTOS调度器可以使用以下两种方法中的一种来决定哪一个任务处于运行态。configMAX_PRIORITIES的取值由使用的决策方法决定。（可以理解为切换任务的代码？）**

**通用方法**

通用方法用C代码实现，可以被FreeRTOS的所有架构端口使用。通用方法对configMAX_PRIORITIES的最大取值没有限制，但强烈推荐其取值够用就好，过大的优先级会浪费RAM，最坏情况下的执行时间也会加长。

当FreeRTOSConfig.h文件中configUSE_PORT_OPTIMISED_TASK_SELECTION被设置为0或未定义（undefined）时，使用通用方法。另外如果FreeRTOS port只提供该方法，则只能用它。

**结构优化方法**

结构优化方法使用一小段汇编语言，比通用方法更快。configMAX_PRIORITIES的设置不影响最坏情况下的执行时间。但使用结构优化方法时，改值的大小不能超过32。同样也强烈建议够用就好，过大，依然或浪费RAM。

当FreeRTOSConfig.h文件中configUSE_PORT_OPTIMISED_TASK_SELECTION设置为1时，将会使用该方法，不是所有的FreeRTOS ports都提供一个结构优化方法。

FreeRTOS调度器会确保当前可运行的任务中任务优先级最高的进入运行状态，如果由多个任务处于最高优先级，则调度器将轮流运行它们。

#### 3.4 时间度量 & Tick中断（重点，调度器什么时候调度）

在后面的调度算法章节中将会讲述被称为时间片的可选特征。到目前位置，前面的例子（在书中，我没摘抄下来）中都使用的时时间片，从他们的输出中可以观察到时间片的使用。在例子中，两个任务创建时拥有相同的优先级，都可以运行。因此，每个任务运行一个时间片的时间，在时间片开始时进入运行态，在时间片结束时退出运行态。在下图中，t1到t2之间的时间长度为一个时间片。

![image-20200808165422689](FreeRTOS_illustration/image-20200808165422689.png)

**为了能够选择下一个要执行的任务，调度器本身必须在每个时间片结束时运行。被称为tick interrupt的周期中断，就是为了此目的。**时间片的长度由tick终端频率决定，该常量configTICK_RATE_HZ的值在FreeRTOSConfig.h文件中定义，编译时配置完成。举个栗子，如果**configTICK_RATE_HZ**设置为100，则时间片的长度为10毫秒。两次tick中断之间的长度称为tick周期，其就等于一个时间片的长度。

**注意**：**调度器选择新任务的执行，不只是在时间片结束时，在当前任务处于阻塞状态或者当发生中断并移动一个更高优先级的任务进入就绪态时，调度器会立即选择一个新的任务去执行。**

configTICK_RATE_HZ的值取决于你设计的应用程序，一般取值为100。

调用FreeRTOS应用程序接口时指定的时间总是滴答周期的倍数，该时间经常被叫做“ticks”。pdMS_TO_TICKS()宏可以将以毫秒为单位的时间转换为ticks周期数。转换的精度取决于定义的滴答频率configTICK_RATE_HZ，当滴答频率大于1000时该宏不能被使用。使用该宏指定时间的优点是，当tick频率改变时指定的时间仍然是xx毫秒。

#### 3.5 详述S非运行状态

之前例子（在手册中，未摘抄）中，任务不需要等待什么东西，因此它将经常可以进如运行态，但实际上这种连续性任务是没多大用处的，这种任务的运行会阻碍比它优先级低的任务进入运行态。

为了使任务发挥更大的用处，必须重新编写它们使之成为事件驱动（event-driven）。事件驱动任务只有在触发该任务的事件发生时才会被执行，在其他情况下不会进入运行态。调度器经常选择能够被执行的任务中优先级最高的那个任务。

##### 3.5.1 阻塞状态（Blocked StateS）

任务在等待事件发生被称作阻塞态。任务进入阻塞态可能是等待以下两个事件的发生。

1. 时间（相关）事件--事件可能是延时到期或者到了一个绝对时间。例如，任务可能因为等待10ms延时到期而进入阻塞状态。
2. 同步事件--事件由其他任务或中断引起。例如，任务可能因到等待到达某个队列的数据而进入阻塞状态。

FreeRTOS queue, binary semaphores, counting semaphores, mutexes, recurisive mutexes（递归互斥量）, event group and **direct to task notifications**都可以被用来创建同步事件。

任务也有可能被一个带有延时到期的同步事件阻塞，即同时被两种类型的事件阻塞。例如，任务可能选择等待数据到达一个队列的最大时间为10ms。如果数据在10ms内到达或者超过10ms后没有到达，任务都将离开阻塞状态。

##### 3.5.2 挂起状态（Suspended State）

处于挂起状态的任务将不能被调度器调度。进入挂起状态的唯一方法就是通过调用vTaskSuspend()应用函数，退出挂起状态的唯一方法就是通过调用vTaskResume() 或vTaskResumeFromISR()应用函数。大部分的应用不使用挂起状态。

##### 3.5.3 就绪状态（Ready State）

不在运行态且不在阻塞态且不在挂起态，那就是在就绪态。它们具备了被执行（运行）的能力，时刻准备着去运行。

##### 3.5.4 完整的状态转换图示

![image-20200809201608956](FreeRTOS_illustration/image-20200809201608956.png)

更优秀的例子在内核使用手册中。

**vTaskDelay()函数**

在之前的例子中使用的延时手段会占用处理器的运行时间，在延时这段时间内其实任务没有需要做的工作，这浪会费资源，因此使用**vTaskDelay()**函数来进行延时，并使得调用延时的任务进入阻塞状态，把处理器暂时让出来供其他任务使用。在FreeRTOSConfig.h文件中设置**INCLUDE_vTaskDelay**设置为1时，vTaskDelay()函数才能够被调用。其函数原型如下图所示：

![image-20200809203320172](FreeRTOS_illustration/image-20200809203326630.png)

**参数**

xTicksToDelay：调用该延时函数的任务从阻塞态转换为就绪态所持续的滴答中断的数量。例如，一个任务调用函数vTaskDelay( 100 )时滴答计数的值为10000，此时该任务立即进入阻塞态，一直持续到滴答计数增长到10100时。宏pdMS_TO_TICKS()可以用来将以毫秒为单位的时间值转换为相应的滴答中断（周期）数。下图为一个任务函数：

![image-20200809205020595](FreeRTOS_illustration/image-20200809205020595.png)

当调度器被调用时，为了保证在任一时刻至少有一个任务可以运行（或者说在就绪状态），空闲任务（idle task）自动被创建。

**vTaskDelayUntil()函数**

vTaskDelayUnitl()的参数指定了精确的滴答计数值，在达到该计数值时，调用vTaskDelayUntil()函数的任务应从阻塞态转为就绪态。vTaskDelayUntil()函数用于有固定执行周期的需求任务（当你想要你的任务以一个固定的频率，周期性的执行），因为调用任务被解除阻塞的时间是绝对的，而不是相对于函数被调用的时间。其函数原型如下图所示：

![image-20200809223359071](FreeRTOS_illustration/image-20200809223359071.png)

**参数**

pxPreviousWakeTime：该参数的命名建立在vTaskDelayUntil()函数被用于一个以固定频率，周期性地执行任务的假设上。在该假设下，pxPreviousWakeTime参数值为该任务上一次退出阻塞状态（被唤醒）的时刻，该值用作计算下一次该任务退出阻塞状态时刻的参考点。pxPreviousWakeTime参数的值在vTaskDelayUntil()函数中自动更新，该参数的值在首次使用该参数时用当前的滴答计数值初始化后，一般不会被应用代码修改。

xTimeIncrement：该名字的又来同上假设，任务的固定频率由该参数的值所设置。单位为ticks，同样宏pdMS_TO_TICKS()可以将以毫秒为单位的时间转换为tick数量。

***********************************************************************************************************************************************************************************************

下图为结合了周期性任务和连续性任务的示例执行时序图，下图中的例子在手册中。

![image-20200809232247292](FreeRTOS_illustration/image-20200809232247292.png)

#### 3.6 空闲任务 & 空闲任务钩子（The Idle Task & the Idle Task Hook）

##### 3.6.1 空闲任务

空闲任务的优先级应尽可能低（0优先级），保证不能影响其他高优先级任务进入运行态。如果你非要创建一个任务优先级域空闲任务相同的应用任务，则FreeRTOSconfig.h文件中定义的静态常量（compile time configuration constant）configIDLE_SHOULD_YIELD可以用于防止空闲任务消耗处理器时间，保证分配CPU给应用任务。

以最低优先级运行可以确保当高优先级任务进入就绪态时，空闲任务就会从运行状态转移出去。当高优先级的任务退出阻塞状态时，空闲任务立即退出运行以保证高优先级的任务被执行。这被称作**高优先级抢占了空闲任务**。**抢占自动发生，并且它不知道抢占了谁**。

注意：如果在程序中使用了vTaskDelete()函数，那么必须确保空闲任务可以进入运行态。这是因为空闲任务要在任务被删除之后清理内核资源。

##### 3.6.2 空闲任务钩子函数

可以通过使用空闲钩子（或空闲回调）函数将特定于应用程序的功能直接添加到空闲任务中，空闲钩子函数会在空闲任务的每一个循环自动调用一次。（将功能添加到空闲钩子函数中，空闲钩子函数会在空闲任务的每一循环自动调用一次）

**空闲任务钩子的常见用途包括：**

- 执行低优先级、后台或连续处理功能。

- 度量空闲处理能力数量。

- 使处理器进入低功耗模式，每当应用不需要工作的时候，提供一个简单的自动节能方法，尽管该方法的效果远低于使用tick-less空闲模式的节能效果。

**使用空闲任务钩子函数的条件：**

空闲任务钩子函数必须遵从以下规则

- 空闲任务钩子函数绝不能试图阻塞或者挂起。阻塞空闲任务可能会造成没有能够进入运行态的任务。
- 如果应用程序使用了vTaskDelete()函数，那么空闲任务钩子必须在一个合理的时间内返回到它的调用者（空闲函数吗）。如果空闲任务永久的在钩子函数里，当有任务被删除时，那它就不能清理内核资源了。

下图为空闲钩子函数的一个实例：

![image-20200810175504541](FreeRTOS_illustration/image-20200810175504541.png)

空闲钩子函数必须以vApplicationIdleHook()命名，且没有参数，也返回空void。**自动被调用。**

必须将FreeRTOSconfig,h头文件中的configUSE_IDLE_HOOK设置为1才能调用空闲钩子函数。

#### 3.7 修改任务优先级

在调度器开始调度之后，vTaskPrioritySet()函数可以修改任意任务的优先级。不过要使用vTaskPrioritySet()函数必须在FreeRTOSconfig.h头文件中将INCLUDE_vTaskPrioritySet设置为1。其函数原型如下图所示：

![image-20200810183710171](FreeRTOS_illustration/image-20200810183710171.png)

**参数**

pxTask：将要被修改优先级的任务句柄。任务可以通过想改参数传递NULL来修改自己的优先级。

uxNewPriority：任务的新优先级。

uxTaskPriorityGet()函数可以用来询问任务的优先级。要使用该函数，需在FreeRTOSconfig.h头文件中将INCLUDE_uxTaskPriorityGet设置为1。其函数原型如下图所示：

![image-20200810184600461](FreeRTOS_illustration/image-20200810184600461.png)

**参数**

pxTask：被询问优先级的任务句柄。任务可以通过NULL作为该参数值询问自己的优先级。

**返回值**

询问时该任务的优先级。

#### 3.8 删除任务

任务可以使用vTaskDelete()函数删除自己，也可以被其他函数删除。只有在FreeRTOSconfig.h头文件中将INCLUDE_vTaskDelete设置为1时，该函数才能被调用。

删除不再存在及不能再进入运行态的任务。当任务被删除之后，释放分配给该任务的内存是idle task的工作。因此，应用程序在任何情况下使用vTaskDelete()函数删除任务时，不能完全starve空闲任务是非常重要的。

**注意：****当任务被删除时，只有内核自己分配给任务的内存会被自动释放。任务自己申请的任何内存或资源需被显式的释放。**就是你在程序中自己申请的变量，需要自己显式地释放。

vTaskDelete()函数的原型如下图所示：

![image-20200810195558450](FreeRTOS_illustration/image-20200810195558450.png)

**参数**

pxTaskToDelete：要被删除的函数句柄。任务可以通过输入NULL作为该参数值删除自己。

例子在手册中，下图是例子的执行时序图。

![image-20200810200542602](FreeRTOS_illustration/image-20200810200542602.png)

#### 3.9 线程本地存储（Thread Local Storage）

这一节内容在最终版本中将会讲述。

wocao!看到现在这个发现手册竟然不是最终版本。

算了，继续看吧！

#### 3.10 调度算法（重要）

##### 3.10.1 调度器总是选择就绪态中优先级最高的任务进入运行态。

任务在阻塞态等待事件，当事件发生后自动转入就绪态。事件有时间事件和同步事件。

**Temporal events**：发生在特定的时间，例如，延时到期，通常用于实现周期或超时的行为。

**Synchronization events**：发生在当任务或者中断服务程序发送信息时，信息的发送可以使用任务通知、队列、事件组或者某种类型的信号量。它们经常被用来表示异步行为，例如数据到达某一外设。

##### 3.10.2 配置调度算法

调度算法时用于决定哪一个就绪态的任务进入运行态的软件程序。

调度算法可以在FreeRTOSConfig.h头文件中通过配置**configUSE_PREEMPTION和configUSE_TIME_SLICING**两个常量选择所使用的调度算法。除了这两个关键常量外，configUSE_TICKLESS_IDLE也对调度算法有影响，当使用它时，可以使滴答中断完全关闭以达到扩展周期的效果。**configUSE_TICKLESS_IDLE**是一个高级选项，它可以用在必须有最小耗电的应用中。

##### 3.10.3 使用时间分片优化抢占机制

大多数的小型实时应用程序都采用被称作“Fixed Priority Pre-emptive Scheduling with Time Slicing”的调度算法。也就是配置上面那两个参数为1时系统所使用的调度算法。

Fixed Priority：所谓固定优先级，就是调度算法不改变被调度任务所分配的优先级，但也不阻止任务自己改变自己或者其它任务的优先级。

Pre-emptive：所谓抢占，就是当一个进入就绪态的任务的优先级比正在运行的任务优先级高，则会立即抢占运行态。被抢占的任务则自然切出运行态并进入就绪态以允许其他任务进入运行态。

Time Slicing：时间分片用来使相同优先级的任务共享运行时间，任务不会进入阻塞或者挂起态。调度器会在每个时间片结束时选择一个新的同优先级的就绪态任务进入运行态，一个时间片就是两个滴答中断之间的时间长度。

调度机制可以参看下面两个图：

![image-20200811235513052](FreeRTOS_illustration/image-20200811235513052.png)

![image-20200811235620794](FreeRTOS_illustration/image-20200811235620794.png)

有关上图详细的解释，尽在手册中。

图27中的情形是不太合适的，因为分配给空闲任务的运行时间太多了，因此可以利用钱买你提到的可选的高级选项configIDLE_SHOULD_YIELD来优化系统的调度算法。当该常量设置为0是，既是图27所示，配置为1时，则如下图28所示：

![image-20200812001615861](FreeRTOS_illustration/image-20200812001615861.png)

当配置为1时，如果有同空闲任务优先级的任务进入就绪态时，空闲任务将自动的在其循环的每次迭代中退出运行态，不管它的时间片还剩下多少。（**空闲任务会执行一个循环**）

从图中也可以看出，任务2的执行时间不等于整个时间片，而是空闲任务退出运行态时剩余的的时间段。

##### 3.10.4 优先级抢占调度（无时间片）

与前面看过的带时间片的调度算法相比，无时间片是不能在相同优先级的任务之间共享处理时间的。当然，需要在FreeRTOSconfig.h头文件中将configUSE_TIME_SILCING设置为0。

滴答中断的发生预示了一个时间片的结束。不使用时间片时调度器只有在以下两种情况下才会选择一个新任务进入运行态。

- 一个更高优先级的任务进入就绪态。

- 运行态的任务进入阻塞态或者被挂起。

不使用时间片轮调，会少产生很多上下文切换。因此，也降低了调度器的处理开支。但，如下图所示，不使用时间片轮调会造成分配给具有相同优先级任务的运行时间相差很大。所以，不建议你使用这种算法，除非你是很有经验的开发者。

![image-20200812131731188](FreeRTOS_illustration/image-20200812131731188.png)

##### 3.10.5 协作调度（Co-operative Scheduling）

FreeRTOS也提供了协作调度机制，要使用该调度机制只需在FreeRTOSconfig.h头文件中设置configUSE_PREEMPTION为0，configUSE_TIME_SLICING为任意值。

当使用协作调度算法时，任务的上下文切换将只发生在运行态任务进入阻塞态或者处于运行态的任务通过调用taskYIELD()函数被显示地挂起（手动请求调度器重新调度）时。其他任何情况下，任务不会被抢占，时间片调度机制也不会被使用。下图展示了该调度算法的行为。

![image-20200812135042369](FreeRTOS_illustration/image-20200812135042369.png)

在多任务应用中，程序开发者应格外小心同一个资源不能同时被多个任务同时使用，例如两个任务都向一个串口写入数据，任务1写入“abcdefghijklmnop”，任务2写入“123456789”：

1. 任务1处于运行态，向串口输入“abcdefg”之后，离开运行态进入阻塞态，此时数据没写完。

2. 任务2紧接着进入运行态，并在离开运行态时写入“123456789“到串口。

3. 任务1重新进入运行态并继续写入之前未写完的字符。

在以上的情形中其实向串口写入的字符串是”abcdefg123456789hijklmnop“，这通常不是我们想要的结果。

自然的，使用协作调度时可以避免这种情况的发生。因此在以上例子这类情况发生时，使用该机制要比使用抢占式调度机制更好。

### 4 队列管理

队列（Queues）提供了一个任务到任务、任务到中断、中断到任务的通信机制。

