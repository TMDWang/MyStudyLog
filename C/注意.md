##### 1 变量初始化

变量在声明是需要初始化，要不然它的初始值将是一个不可预料的值，也就是垃圾。不过如果你对这个变量的第一个操作就是对它赋值，也可以不在声明时对其初始化。

```
int a = 223;
int b;

b = max(32, 223);  //对b的第一个操作就是对其赋值。
```

##### 2 空语句

while语句（或其他）之后的单独一个分号称为**空语句（empty statement）**,它就是应用于下面的场合，即语法要求这个地方出现一条语句但又无需执行任何任务的时候，这个分号独占一行，这是为了防止读者错误地以为接下来的语句也是循环体的一部分。

```
while(1)  //这是个死循环
{  //可以省去的
	;  //空语句
}

statement;
```

##### 3 数组

当数组名作为实参时，传给函数的实际上是一个指向数组起始位置的指针，也就是数组在内存中的地址。正因为实际传递的是一个指针而不是一份数组的拷贝，才使数组名作为参数时具备了传址调用的语义。函数可以按照操纵指针的方式来操纵实参，也可以像使用数组名一样用下标来引用数组的元素。

##### 4 结构体字节对齐 & 占用字节数

字节对齐原则：

1. 以结构体成员中占内存最多的数据类型所占的字节数为标准，所有的成员在分配内存时都要与这个长度对齐。
2. 在1的基础上，如果占内存最多的数据类型所占的字节数为N，理论上所有成员在分配内存时都是紧接在前一个变量后面依次填充的，但是如果是“以N对齐”为原则，那么，如果一行中剩下的空间不足以填充某成员变量，即剩下的空间小于某成员变量的数据类型所占的字节数，则该成员变量在分配内存时另起一行分配。

```
结构体1
struct student1
{
	char a;  //char类型变量占1字节内存空间
	char b;
	int  c;  //int类型变量占4字节内存空间
}data1;

结构体2
struct student2
{
	char a;
	int  c;
	char b;
}data2;

结构体3
struct student3
{
	char  name[10];  //占内存长度为10，但本质上是10个char变量，看成10个char变量即可
	int   age;
	char  sex;
	float score;     //float类型变量占4字节内存空间
}data3;
```

以上三个结构体分别占8、12、24字节内存空间。

##### 5 函数指针

函数的函数名实际上就是一个指针，函数名指向噶函数的代码在内存中的首地址。

**用法1：返回类型 (*函数名) (参数表)**

```
char (*pFun)(int);
char glFun(int a)
{
	return;
}

void main()
{
	pFun = glFun;  //将glFun函数赋值给函数指针pFun
	(*pFun)(2);    //*取值运算符，*pFun即glFun
}
```

**用法2：typedef 返回类型(*新类型)(参数表)**

```
typedef char (*PTRFUN)(int);
PTRFUN pFun;
char glFun(int a)
{
	return;
}

void main()
{
	pFun = glFun;
	(*pFun)(2);
}
```

typedef的功能是定义新的类型。第一句就是定义了一种PTRFUN的类型，并定义这种类型为指向某种函数的指针，这种函数以一个int为参数并返回char类型。后面就可以像使用类型声明符“int”、“char”一样使用PTRFUN定义函数指针变量了。

##### 6 函数指针列表



##### 7 共用体(union)



##### 8 运算符的优先级

- 强制类型转换的优先级 > 移位运算符（"<<", ">>"）



